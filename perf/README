The files in this directory are used to run performance related tests
on the RadixIPLookup element. Currently there are 5 sets of tests
which can be run:

1. 167k -- Uses the 167k routing table and evaluated RadixIPLookup
elements using a 5 million long randomly generated TCP dump file (5mtest.dump)

2. 1m_20 -- Uses a routing table consisting of all 2^20 /20 
routes. RadixIPLookup is evaluated using a 5 million long randomly
generated TCP dump file (5mtest.dump)

3. 1m_gt20 -- Uses a routing table consisting of 2^20 evenly
distributed /20,/24,/28,/32 routes. RadixIPLookup is evaluated using a
5 million long randomly generated TCP dump file (5mtest.dump)

4. 1m_32 -- Uses a routingable consisting of 2^20 evenly /32
addresses. These addresses are evenly distributed throughout the /32
address space. RadixIPLookup is evaluated using a 5 million long TCP
dump file consisting of all the IP addresses which match the routes in
the routing table. These addresses are repeated 5 times and randomly
shuffled. The TCP dump file is 5mshuffle.dump

5. 366k -- Uses a realistic routing table obtained from the routeviews
FIB. Contains ~ 366K routes with around 40 next hops. Evaluated using
5 million random IP addresses (5mtest.dump)


All the tests can be running the "make" command within the perf
directory. 

Usage:
	make

To run a specific test class you can pass that class as an argument to
make. For example to run only the 167k tests, you would run:

      make 167k

Additional options include specifying the number of times the tests
should be run and the conf file:

       make 167k n=10 conf=myconf.conf

The "conf" file contains the index numbers of radix elements to be
used. For an example conf file see "default.conf". If no options are
given make assumes that "n=10" and "conf=default.conf". The Makefile
actually invokes another shell script called "testrunner.sh" which is
described in the next paragraphs.

The testrunner.sh file runs each one of these files using "click
radix[1-6].click" and times the result using the "time" program. 

The testrunner.sh takes an argument N which is the number of times
each click file needs to be run. The test to be run and the input TCP
dump file to be used. The times are averaged and stored in
a ".click.out" file.

Usage:

	./testrunner.sh <n> <input_prefix> <conf> <dump_file>

n		= number of times the test should be run
input_prefix  	= the prefix of the radix1.click file which 
	      	  which should be used. One from 167k, 1m_gt20, 1m_20
		  and 1m_32.
conf		= configuration file which specifies the radix
		  elements to be used.
dump_file	= The input dump file


The "conf" file contains the suffixes of the RadixIPLookup elements to
be evaluated. For example to evaluate RadixIPLookup and
RadixIPLookup7, the conf file will contain two lines:

1
7

The radix.click and setup.click files are generated on the fly by the
testrunner.sh program. These files are then run with click and is
timed using "time." The time of each run is averaged and the final
results are printed out on stdout as a CSV file.

The "mean.sh" program computes the mean wall clock time and also the
maximum resident working set. The "mean" binary program (used by
"mean.sh") computes the average of the numbers it sees on stdin.


More statistics regarding the CSV file can be obtained by passing the
CSV file to the shell script "perftable.sh" (requires R)

Usage:
	./perftable.sh <input_csv> <output_csv>

input_csv: The CSV output generated by testrunner.sh
output_csv: The performance statistics for the input

Raw cache related data can be obtained by running the "cacherunner.sh"
script (requires valgrind and cachegrind).

Usage:
	./cacherunner.sh <input_prefix> <conf> <dump_file>

input_prefix  	= the prefix of the radix1.click file which 
	      	  which should be used. One from 167k, 1m_gt20, 1m_20
		  and 1m_32.
conf		= configuration file which specifies the radix
		  elements to be used.
dump_file	= The input dump file

The conf file contains the index of the RadixIPLookup elements to be
profiled, one on each line.


The description of each RadixIPLookup element is given below.

Element			Description
---------------------------------------------------------------------
RadixIPLookup		The original RadixIPLookup element. With
			branching factor 2^8 at the first level and 2^4
			after that.

RadixIPLookup2		Radix nodes memaligned to 64 bytes. Branching
			factor of 2^8 at first level and 2^3 after that.

RadixIPLookup3		Branching factor of 2^8 at first level and 2^3
			after that.

RadixIPLookup4		Branching factor of 2^8 at first level and 2^2
			after that.

RadixIPLookup5		Branching factor of 2^16 at first level and
			2^4 after that.

RadixIPLookup6		Radix nodes memaligned to 64 bytes. Super
			children allocated in a separate call to
			new. Branching factor of 2^8 at the first
			level and 2^3 after that.

RadixIPLookup7		RadixIPLookup7 doesn't have the following
			member fields "_bitshift", "_n",
			"_nchildren". These fields are derived
			automatically from the depth at which a
			particular node is at. It has additional
			functions to calculate these fields. Branching
			factor of 2^12 at first level and 2^5 after that.

RadixIPLookup8		Branching factor of 2^12 at first level and
			2^5 after that. Used to compare performance
			against RadixIPLookup7.
			
RadixIPLookup9		Branching factor of 2^16 at first level and
			2^4 after that. Derivable fields removed.

RadixIPLookup10		Branching factor of 2^16 at first level and
			2^16 at 2nd level. Derivable fields removed.

RadixIPLookup11		Branching factor of 2^8 at first level and 2^8
			after that. Derivable fields removed.

RadixIPLookup12		Branching factor of 2^16 at first level and
			2^5 after that. Derivable fields removed.

RadixIPLookup13		Branching factor of 2^12 at first level and 
			2^5 after that. Derivable fields
			removed. Bitshift and nbuckets are calculated
			with the help of a static array.

RadixIPLookup14		Branching factor of 2^12 at first level and
			2^5 after that. Derivable fields
			removed. Fields allocated using custom allocator.

RadixIPLookup15		Branching factor of 2^16 at first level and
			2^5 after that. Derivable fields
			removed. Bitshift and nbuckets are calculated
			with the help of a static array.

RadixIPLookup16		Branching factor of 2^12 at first level and
			2^5 after that. Derivable fields
			removed. Bitshift and nbuckets are calculated
			with the help of a static array. Uses intel
			specific software prefetch instruction
			prefetcht0 to prefetch child nodes during lookup.

RadixIPLookup18 	Uses custom allocator. Super children are
			indexed with the help of a separate hash
			table.

RadixIPLookup19		Branching factor of 2^12 at first level and
			2^5 after that. Derivable fields
			removed. Bitshift and nbuckets are calculated
			with the help of a static array. The top 4
			bits of the "key" index into a different
			(most likely) smaller "lookup table" which
			maintains only unique "gw" and "port"
			combinations. This saves cache misses as we
			don't need to access the large "_v" table.

RadixIPLookup20		Branching factor of 2^12 at first level and
			2^5 after that. Uses static array to find
			values for _bitshift and _nbuckets. Has a
			single bit embedded within each key called
			"has_child" which tells whether a particular
			radix child element has children or not. The
			keys and radix pointers are laid out in a
			block format instead of being interleaved.

			Layout Before
			[key | radix *, key | radix * .... ]

			In RadixIPLookup20
			
			[key | has_key, key | has_key,  .. radix *, radix *..]

RadixIPLookup21		Branching factor of 2^12 at first level and 2^5 after
			that. Uses a skip key to avoid linear
			branches. A linear branch is one where an
			internal node in a tree has only one child,
			and that child has only one child, so on all
			the way to a leaf node.

			For example:

				A
			       / \
		              B
		             / \
		            C 
		           / \
		          D
			
			In the above example, A only has one child B,
			which in turn has only one child C. D, which
			is the only child of C, is a leaf node, hence
			we have a linear branch all the way from A-D.

			Instead of having the nodes B and C, we could
			directly connect A to D.

		          ------A
			  |
		          |
		          |
		          |
		          D
		
			Whenever a key is added to be added to a Radix
			node, we check whether it is the first node
			being added to the radix tree. If that is the
			case, then we directly add that key as a skip
			key.
  